
%% Simulate hermite-simpson control open loop
x0 = [0; 0; 0];
t0 = 0;
traj_tf = num_waypoints * tf;
ctrl_t = linspace(t0, traj_tf, length(v_traj));
states = [x_traj y_traj theta_traj];

[tout, sim_x] = ode45(@(t,y) robot_simulation(t,y,states,v_traj,w_traj, ctrl_t), [t0 traj_tf], x0);

% 2D Trajectory
figure(1)
plot(sim_x(:,1), sim_x(:,2))
hold on
plot(states(:,1), states(:,2))
hold off
legend('simulation', 'plan')
xlabel("x")
ylabel("y")

function dxdt = robot_simulation(t, x, states, v, w, ctrl_t)
    % Interpolate direct collocation input
    v_in = interp1(ctrl_t, v, t);
    w_in = interp1(ctrl_t, w, t);
    state = interp1(ctrl_t, states, t);
    
    % Make input vector
%     U = [v_in; w_in];
%     
%     K = [10 10 0;
%          0    0  10];
%     u = U + K*(x - state);

    % Control gains
    k1 = 

    % Find error in robot frame
    delta = state - x;
    theta = x(3);
    R = [cos(theta) sin(theta) 0;
        -sin(theta) cos(theta) 0;
             0          0      1];
    E = R*delta;
    ex = E(1);
    ey = E(2);
    et = E(3);
    
    u = [-k1 * ex;
         -k2 * v_in * sinc(et) * ey - k3 * et];
    
    % Find derivatives of nonlinear system
    dxdt = differential_drive(x, u);
end

function s = sinc(